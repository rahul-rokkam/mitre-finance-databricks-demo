/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * financial-command-center
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import * as axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";

export type ComplexValueDisplay = string | null;

export type ComplexValuePrimary = boolean | null;

export type ComplexValueRef = string | null;

export type ComplexValueType = string | null;

export type ComplexValueValue = string | null;

export interface ComplexValue {
  display?: ComplexValueDisplay;
  primary?: ComplexValuePrimary;
  ref?: ComplexValueRef;
  type?: ComplexValueType;
  value?: ComplexValueValue;
}

/**
 * Existing conversation ID for follow-ups
 */
export type GenieMessageInConversationId = string | null;

/**
 * Input for sending a message to Genie
 */
export interface GenieMessageIn {
  /** The schema to query */
  schema_name: SchemaType;
  /** The user's question */
  message: string;
  /** Existing conversation ID for follow-ups */
  conversation_id?: GenieMessageInConversationId;
}

export type GenieMessageOutStatus =
  (typeof GenieMessageOutStatus)[keyof typeof GenieMessageOutStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GenieMessageOutStatus = {
  pending: "pending",
  completed: "completed",
  failed: "failed",
} as const;

export type GenieMessageOutQueryResult = GenieQueryResult | null;

export type GenieMessageOutError = string | null;

/**
 * Response from Genie
 */
export interface GenieMessageOut {
  conversation_id: string;
  message_id: string;
  response: string;
  status: GenieMessageOutStatus;
  query_result?: GenieMessageOutQueryResult;
  error?: GenieMessageOutError;
}

export type GenieQueryResultSql = string | null;

/**
 * Query result from Genie
 */
export interface GenieQueryResult {
  columns?: string[];
  rows?: unknown[][];
  sql?: GenieQueryResultSql;
}

/**
 * Configuration for a Genie space
 */
export interface GenieSpaceConfigOut {
  schema_name: string;
  space_id: string;
  display_name: string;
}

export type GenieSpacesOutSpaces = { [key: string]: GenieSpaceConfigOut };

/**
 * All configured Genie spaces
 */
export interface GenieSpacesOut {
  spaces: GenieSpacesOutSpaces;
}

export type GenieStatusOutStatus =
  (typeof GenieStatusOutStatus)[keyof typeof GenieStatusOutStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GenieStatusOutStatus = {
  pending: "pending",
  completed: "completed",
  failed: "failed",
} as const;

export type GenieStatusOutResponse = string | null;

export type GenieStatusOutQueryResult = GenieQueryResult | null;

export type GenieStatusOutError = string | null;

/**
 * Status of a Genie message
 */
export interface GenieStatusOut {
  conversation_id: string;
  message_id: string;
  status: GenieStatusOutStatus;
  response?: GenieStatusOutResponse;
  query_result?: GenieStatusOutQueryResult;
  error?: GenieStatusOutError;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type NameFamilyName = string | null;

export type NameGivenName = string | null;

export interface Name {
  family_name?: NameFamilyName;
  given_name?: NameGivenName;
}

export type SchemaType = (typeof SchemaType)[keyof typeof SchemaType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SchemaType = {
  "financial-health": "financial-health",
  "program-portfolio": "program-portfolio",
  "sponsor-funding": "sponsor-funding",
  "risk-compliance": "risk-compliance",
  "government-relations": "government-relations",
} as const;

export type UserActive = boolean | null;

export type UserDisplayName = string | null;

export type UserEmails = ComplexValue[] | null;

export type UserEntitlements = ComplexValue[] | null;

export type UserExternalId = string | null;

export type UserGroups = ComplexValue[] | null;

export type UserId = string | null;

export type UserName = Name | null;

export type UserRoles = ComplexValue[] | null;

export type UserSchemas = UserSchema[] | null;

export type UserUserName = string | null;

export interface User {
  active?: UserActive;
  display_name?: UserDisplayName;
  emails?: UserEmails;
  entitlements?: UserEntitlements;
  external_id?: UserExternalId;
  groups?: UserGroups;
  id?: UserId;
  name?: UserName;
  roles?: UserRoles;
  schemas?: UserSchemas;
  user_name?: UserUserName;
}

export type UserSchema = (typeof UserSchema)[keyof typeof UserSchema];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSchema = {
  "urn:ietf:params:scim:schemas:core:20:User":
    "urn:ietf:params:scim:schemas:core:2.0:User",
  "urn:ietf:params:scim:schemas:extension:workspace:20:User":
    "urn:ietf:params:scim:schemas:extension:workspace:2.0:User",
} as const;

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface VersionOut {
  version: string;
}

export type GetGenieMessageStatusParams = {
  schema_name: SchemaType;
};

/**
 * @summary Version
 */
export const version = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VersionOut>> => {
  return axios.default.get(`/api/version`, options);
};

export const getVersionQueryKey = () => {
  return [`/api/version`] as const;
};

export const getVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionQueryError = AxiosError<unknown>;

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVersionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionSuspenseQueryError = AxiosError<unknown>;

export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Me
 */
export const currentUser = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<User>> => {
  return axios.default.get(`/api/current-user`, options);
};

export const getCurrentUserQueryKey = () => {
  return [`/api/current-user`] as const;
};

export const getCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCurrentUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUser>>> = ({
    signal,
  }) => currentUser({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof currentUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof currentUser>>
>;
export type CurrentUserQueryError = AxiosError<HTTPValidationError>;

export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUser>>,
          TError,
          Awaited<ReturnType<typeof currentUser>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUser>>,
          TError,
          Awaited<ReturnType<typeof currentUser>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Me
 */

export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCurrentUserQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCurrentUserSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof currentUser>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCurrentUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUser>>> = ({
    signal,
  }) => currentUser({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof currentUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CurrentUserSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof currentUser>>
>;
export type CurrentUserSuspenseQueryError = AxiosError<HTTPValidationError>;

export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Me
 */

export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCurrentUserSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get all configured Genie spaces
 * @summary Get Genie Spaces
 */
export const getGenieSpaces = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GenieSpacesOut>> => {
  return axios.default.get(`/api/genie/spaces`, options);
};

export const getGetGenieSpacesQueryKey = () => {
  return [`/api/genie/spaces`] as const;
};

export const getGetGenieSpacesQueryOptions = <
  TData = Awaited<ReturnType<typeof getGenieSpaces>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGenieSpaces>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGenieSpacesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenieSpaces>>> = ({
    signal,
  }) => getGenieSpaces({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGenieSpaces>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGenieSpacesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenieSpaces>>
>;
export type GetGenieSpacesQueryError = AxiosError<unknown>;

export function useGetGenieSpaces<
  TData = Awaited<ReturnType<typeof getGenieSpaces>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenieSpaces>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenieSpaces>>,
          TError,
          Awaited<ReturnType<typeof getGenieSpaces>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenieSpaces<
  TData = Awaited<ReturnType<typeof getGenieSpaces>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenieSpaces>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenieSpaces>>,
          TError,
          Awaited<ReturnType<typeof getGenieSpaces>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenieSpaces<
  TData = Awaited<ReturnType<typeof getGenieSpaces>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenieSpaces>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Genie Spaces
 */

export function useGetGenieSpaces<
  TData = Awaited<ReturnType<typeof getGenieSpaces>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGenieSpaces>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGenieSpacesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGenieSpacesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGenieSpaces>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getGenieSpaces>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGenieSpacesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenieSpaces>>> = ({
    signal,
  }) => getGenieSpaces({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGenieSpaces>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGenieSpacesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenieSpaces>>
>;
export type GetGenieSpacesSuspenseQueryError = AxiosError<unknown>;

export function useGetGenieSpacesSuspense<
  TData = Awaited<ReturnType<typeof getGenieSpaces>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGenieSpaces>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenieSpacesSuspense<
  TData = Awaited<ReturnType<typeof getGenieSpaces>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGenieSpaces>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenieSpacesSuspense<
  TData = Awaited<ReturnType<typeof getGenieSpaces>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGenieSpaces>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Genie Spaces
 */

export function useGetGenieSpacesSuspense<
  TData = Awaited<ReturnType<typeof getGenieSpaces>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGenieSpaces>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGenieSpacesSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Send a message to the Genie space and wait for response
 * @summary Send Genie Message
 */
export const sendGenieMessage = (
  genieMessageIn: GenieMessageIn,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GenieMessageOut>> => {
  return axios.default.post(`/api/genie/message`, genieMessageIn, options);
};

export const getSendGenieMessageMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendGenieMessage>>,
    TError,
    { data: GenieMessageIn },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendGenieMessage>>,
  TError,
  { data: GenieMessageIn },
  TContext
> => {
  const mutationKey = ["sendGenieMessage"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendGenieMessage>>,
    { data: GenieMessageIn }
  > = (props) => {
    const { data } = props ?? {};

    return sendGenieMessage(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendGenieMessageMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendGenieMessage>>
>;
export type SendGenieMessageMutationBody = GenieMessageIn;
export type SendGenieMessageMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Send Genie Message
 */
export const useSendGenieMessage = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendGenieMessage>>,
      TError,
      { data: GenieMessageIn },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sendGenieMessage>>,
  TError,
  { data: GenieMessageIn },
  TContext
> => {
  const mutationOptions = getSendGenieMessageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get the status of a Genie message
 * @summary Get Genie Message Status
 */
export const getGenieMessageStatus = (
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GenieStatusOut>> => {
  return axios.default.get(`/api/genie/status/${conversationId}/${messageId}`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetGenieMessageStatusQueryKey = (
  conversationId?: string,
  messageId?: string,
  params?: GetGenieMessageStatusParams,
) => {
  return [
    `/api/genie/status/${conversationId}/${messageId}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetGenieMessageStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getGenieMessageStatus>>,
  TError = AxiosError<HTTPValidationError>,
>(
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGenieMessageStatus>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetGenieMessageStatusQueryKey(conversationId, messageId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGenieMessageStatus>>
  > = ({ signal }) =>
    getGenieMessageStatus(conversationId, messageId, params, {
      signal,
      ...axiosOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!(conversationId && messageId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGenieMessageStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGenieMessageStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenieMessageStatus>>
>;
export type GetGenieMessageStatusQueryError = AxiosError<HTTPValidationError>;

export function useGetGenieMessageStatus<
  TData = Awaited<ReturnType<typeof getGenieMessageStatus>>,
  TError = AxiosError<HTTPValidationError>,
>(
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGenieMessageStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenieMessageStatus>>,
          TError,
          Awaited<ReturnType<typeof getGenieMessageStatus>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenieMessageStatus<
  TData = Awaited<ReturnType<typeof getGenieMessageStatus>>,
  TError = AxiosError<HTTPValidationError>,
>(
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGenieMessageStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenieMessageStatus>>,
          TError,
          Awaited<ReturnType<typeof getGenieMessageStatus>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenieMessageStatus<
  TData = Awaited<ReturnType<typeof getGenieMessageStatus>>,
  TError = AxiosError<HTTPValidationError>,
>(
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGenieMessageStatus>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Genie Message Status
 */

export function useGetGenieMessageStatus<
  TData = Awaited<ReturnType<typeof getGenieMessageStatus>>,
  TError = AxiosError<HTTPValidationError>,
>(
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGenieMessageStatus>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGenieMessageStatusQueryOptions(
    conversationId,
    messageId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGenieMessageStatusSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGenieMessageStatus>>,
  TError = AxiosError<HTTPValidationError>,
>(
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGenieMessageStatus>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetGenieMessageStatusQueryKey(conversationId, messageId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGenieMessageStatus>>
  > = ({ signal }) =>
    getGenieMessageStatus(conversationId, messageId, params, {
      signal,
      ...axiosOptions,
    });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGenieMessageStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGenieMessageStatusSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGenieMessageStatus>>
>;
export type GetGenieMessageStatusSuspenseQueryError =
  AxiosError<HTTPValidationError>;

export function useGetGenieMessageStatusSuspense<
  TData = Awaited<ReturnType<typeof getGenieMessageStatus>>,
  TError = AxiosError<HTTPValidationError>,
>(
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGenieMessageStatus>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenieMessageStatusSuspense<
  TData = Awaited<ReturnType<typeof getGenieMessageStatus>>,
  TError = AxiosError<HTTPValidationError>,
>(
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGenieMessageStatus>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGenieMessageStatusSuspense<
  TData = Awaited<ReturnType<typeof getGenieMessageStatus>>,
  TError = AxiosError<HTTPValidationError>,
>(
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGenieMessageStatus>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Genie Message Status
 */

export function useGetGenieMessageStatusSuspense<
  TData = Awaited<ReturnType<typeof getGenieMessageStatus>>,
  TError = AxiosError<HTTPValidationError>,
>(
  conversationId: string,
  messageId: string,
  params: GetGenieMessageStatusParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGenieMessageStatus>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGenieMessageStatusSuspenseQueryOptions(
    conversationId,
    messageId,
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
